
    <!DOCTYPE html>
    <html>
      <meta charset="UTF-8" />
      <title>Chainofresponsibility</title>
      <meta
        name="description"
        content="Chain Of Responsibility

왜쓸까

인터넷을 해지하려고 한다.

헬조선식 해지 방법.



이 경로를 고객이 다 알아야 할 필요는 없다.

고객은 맨처음 받은 상"
      />
      <meta name="viewport" content="width=device-width, initial-scale=1" />

      <link
        href="//fonts.googleapis.com/css?family=Rubik|Unica+One"
        rel="stylesheet"
      />
      <link rel="stylesheet" href=".\static/css/normalize.css?f3c97be3b6d9ca15" />
      <link rel="stylesheet" href=".\static/css/flexboxgrid.min.css?f3c97be3b6d9ca15" />
      <link rel="stylesheet" href=".\static/css/github-flavored-markdown.css?f3c97be3b6d9ca15" />
      <link rel="stylesheet" href=".\static/css/light.css?f3c97be3b6d9ca15" />
      <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/solarized-dark.min.css" />
      <style>
        body, .markdown-body {
          font-family: "Rubik|Unica+One", -apple-system, system-ui, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
        }
      </style>
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
      <script src=".\static/main.js?f3c97be3b6d9ca15"></script>
      <body>
        <div id="root"><div class="wrap container-fluid"><header class="site-header"><h1><a href="/">flybook</a></h1><nav class="nav-link"><a href="/">Home</a><a href="https://hearimm">Git</a><a href="#" class="more"><svg aria-hidden="true" class="octicon" height="24" version="1.1" viewBox="0 0 12 16" width="18"><path d="M11.41 9H.59C0 9 0 8.59 0 8c0-.59 0-1 .59-1H11.4c.59 0 .59.41.59 1 0 .59 0 1-.59 1h.01zm0-4H.59C0 5 0 4.59 0 4c0-.59 0-1 .59-1H11.4c.59 0 .59.41.59 1 0 .59 0 1-.59 1h.01zM.59 11H11.4c.59 0 .59.41.59 1 0 .59 0 1-.59 1H.59C0 13 0 12.59 0 12c0-.59 0-1 .59-1z"></path></svg></a></nav></header><section class="row main"><aside class="col-xs-12 col-sm-3 col-md-3 col-lg-3"><div class="chap"><span class="chap-title"></span><ul><li class=""><a href=".%5Cadaptor.html">Adaptor</a></li><li class=""><a href=".%5Citerator.html">Iterator</a></li><li class=""><a href=".%5Ctemplate.html">Template</a></li><li class=""><a href=".%5CabstractFactory.html">Abstractfactory</a></li><li class=""><a href=".%5Cbridge.html">Bridge</a></li><li class=""><a href=".%5Cbuilder.html">Builder</a></li><li class="active"><a href=".%5CchainOfResponsibility.html">Chainofresponsibility</a></li><li class=""><a href=".%5CCommand.html">Command</a></li><li class=""><a href=".%5CeffectiveJavaBuild.html">Effectivejavabuild</a></li><li class=""><a href=".%5Cfacade.html">Facade</a></li><li class=""><a href=".%5CfactoryMethod.html">Factorymethod</a></li><li class=""><a href=".%5CflyWeight.html">Flyweight</a></li><li class=""><a href=".%5CInterpreter.html">Interpreter</a></li><li class=""><a href=".%5Cmediator.html">Mediator</a></li><li class=""><a href=".%5Cmemento.html">Memento</a></li><li class=""><a href=".%5Cobserver.html">Observer</a></li><li class=""><a href=".%5Cprototype.html">Prototype</a></li><li class=""><a href=".%5Cproxy.html">Proxy</a></li><li class=""><a href=".%5Csingleton.html">Singleton</a></li><li class=""><a href=".%5Cstate.html">State</a></li><li class=""><a href=".%5Cvisitor.html">Visitor</a></li></ul></div></aside><article class="col-xs-12 col-sm-9 col-md-9 col-lg-9"><div class="markdown-body"><h1 id="chain-of-responsibility"><a href="#chain-of-responsibility" aria-hidden="true"><span class="icon icon-link"></span></a>Chain Of Responsibility</h1>
<h2 id="왜쓸까"><a href="#%EC%99%9C%EC%93%B8%EA%B9%8C" aria-hidden="true"><span class="icon icon-link"></span></a>왜쓸까</h2>
<p>인터넷을 해지하려고 한다.</p>
<p>헬조선식 해지 방법.</p>
<pre><code>고객 -> 콜센터 상담직원 -> 본사영업관리 -> 담당지역 영업부 -> 담당지역 영업부 해지 방지부서 -> 본사 해지 처리부서 -> 전산부서 -> 딥빡(?)
</code></pre>
<p>이 경로를 고객이 다 알아야 할 필요는 없다.</p>
<p>고객은 맨처음 받은 상담직원한테 '나 해지할거요!' 하고, 해지가 될때까지 기다리면 그만이다.</p>
<p>이렇게 Client 와 Handler(처리하는사람)의 역할을 분리해서,</p>
<p>각각 오브젝트들을 부품처럼 사용하기 위해 사용한다.</p>
<h2 id="책임-떠넘기기"><a href="#%EC%B1%85%EC%9E%84-%EB%96%A0%EB%84%98%EA%B8%B0%EA%B8%B0" aria-hidden="true"><span class="icon icon-link"></span></a>책임 떠넘기기</h2>
<p>Responsibility는 책임이라는 의미이므로 책임을 '떠넘기는 구조'라고 생각하면 편합니다.</p>
<p>이 패턴을 사용하면 '요청하는 쪽'과 '처리하는 쪽'의 연결을 유연하게 해서 각 오브젝트를 <strong>부품으로 독립</strong>시킬 수 있습니다.</p>
<p>또한 상황에 따라서 요청을 처리할 오브젝트가 변하는 프로그램에도 대응할 수 있습니다.</p>
<p>어떤 사람에게 요구를 합니다.그사람이 그것을 처리할 수 있으면, 처리하고, 처리할 수 없으면 그 요구를 <strong>다음 사람</strong>에게 넘깁니다.</p>
<p>다음 사람이 할 수 있으면 하고 없으면, 또 넘깁니다.
이것이 Chain of Responsibility 패턴입니다.</p>
<p>복수의 오브젝트(객체)를 사슬(chain)처럼 연결해 두면,
그 오브젝트(객체)의 사슬을 차례로 돌아다니면서 목적한 오브젝트(객체)를 결정하는 방법</p>
<p>Talk is cheap. Show me the code. -Linus Torvalds
그렇다면 코드로 보자...</p>
<h3 id="트러블-class"><a href="#%ED%8A%B8%EB%9F%AC%EB%B8%94-class" aria-hidden="true"><span class="icon icon-link"></span></a>트러블 class</h3>
<p>트러블을 발생 시킬 클래스 입니다.</p>
<pre><code class="language-java">    public class Trouble {
        private int number; // 트러블 번호

        public Trouble(int number) {
            this.number = number;
        }

        public int getNumber() {
            return number;
        }

        @Override
        public String toString() {
            return "Trouble [number=" + number + "]";
        }
    }
</code></pre>
<h3 id="support-클래스"><a href="#support-%ED%81%B4%EB%9E%98%EC%8A%A4" aria-hidden="true"><span class="icon icon-link"></span></a>Support 클래스</h3>
<p>해결방법등을 정의 할 클래스 입니다.</p>
<p>Abstract Class로 Template패턴을 사용했습니다.</p>
<p>Template패턴은?</p>
<blockquote>
<p>프로세스 흐름을 abstract 클래스에서 메소드를 사용하고, 프로세스 상세 구현은 자식클래스에서 구현</p>
</blockquote>
<p>next필드는 다음 Support클래스를 지정해,
LinkedList 처럼 다음 Support클래스를 불러와서 support(Trouble trouble)메소드를 실행하게 합니다.</p>
<pre><code class="language-java">    public abstract class Support {
        private String name;
        private Support next;

        public Support(String name) {
            this.name = name;
        }
        // LinkedList 처럼 다음에 누가 올지를 set 해준다.
        public Support setNext(Support next) {
            this.next = next;
            return next;
        }

        public final void support(Trouble trouble) { // 트러블 해결의 수순 (Template패턴)
            if (resolve(trouble)) {
                done(trouble);
            } else if (next != null) {
                next.support(trouble);
            } else {
                fail(trouble);
            }
        }

        protected abstract boolean resolve(Trouble trouble); // 해결용 method

        protected void done(Trouble trouble) { // 해결
            System.out.println("Done! " + trouble + " resolved by " + this);
        }

        protected void fail(Trouble trouble) { // 해결 불가
            System.out.println("Fail  " + trouble);
        }

        @Override
        public String toString() {
            return "[" + name + "]";
        }
    }
</code></pre>
<h2 id="support-구현"><a href="#support-%EA%B5%AC%ED%98%84" aria-hidden="true"><span class="icon icon-link"></span></a>Support 구현</h2>
<p>resolve 메소드를 override 해 자신만의 해결법을 작성</p>
<pre><code class="language-java">    public class NoSupport extends Support {
        public NoSupport(String name) {
            super(name);
        }

        @Override
        protected boolean resolve(Trouble trouble) { // 해결 메소드 구현
            return false; // 난 안될거야 아마...
        }
    }


    public class LimitSupport extends Support {
        private int limit;

        public LimitSupport(String name, int limit) {
            super(name);
            this.limit = limit;
        }

        @Override
        protected boolean resolve(Trouble trouble) { // 해결 메소드 구현
            if (trouble.getNumber() &#x3C; limit) { // limit 숫자보다 작을때만 해결!
                return true;
            } else {
                return false;
            }
        }
    }


    public class OddSupport extends Support {
        public OddSupport(String name) {
            super(name);
        }

        @Override
        protected boolean resolve(Trouble trouble) { // 해결 메소드 구현
            if (trouble.getNumber() % 2 == 1) { // odd 만 해결 한다
                return true;
            } else {
                return false;
            }
        }
    }

    public class SpecialSupport extends Support {

        private int specialNumber;

        public SpecialSupport(String name, int specialNumber) {
            super(name);
            this.specialNumber = specialNumber;
        }

        @Override
        protected boolean resolve(Trouble trouble) { // 해결 메소드 구현
            if (trouble.getNumber() == specialNumber) { // specail Number만 해결
                return true;
            } else {
                return false;
            }
        }
    }
</code></pre>
<h2 id="main-클래스"><a href="#main-%ED%81%B4%EB%9E%98%EC%8A%A4" aria-hidden="true"><span class="icon icon-link"></span></a>Main 클래스</h2>
<pre><code class="language-java">    public class Main {

        public static void main(String[] args) {
            Support alice = new NoSupport("Alice");
            Support bob = new LimitSupport("Bob", 100);
            Support charlie = new SpecialSupport("Charlie", 429);
            Support diana = new LimitSupport("Diana", 200);
            Support elmo = new OddSupport("Elmo");
            Support fred = new LimitSupport("Fred", 300);

            alice.setNext(bob).setNext(charlie).setNext(diana).setNext(elmo).setNext(fred);
            // 다양한 트러블 발생
            for(int i = 0; i &#x3C; 500; i += 33) {
                alice.support(new Trouble(i));
            }
        }
    }
</code></pre>
<h2 id="결과"><a href="#%EA%B2%B0%EA%B3%BC" aria-hidden="true"><span class="icon icon-link"></span></a>결과</h2>
<pre><code>Done! Trouble [number=0] resolved by [Bob]
Done! Trouble [number=33] resolved by [Bob]
Done! Trouble [number=66] resolved by [Bob]
Done! Trouble [number=99] resolved by [Bob]
Done! Trouble [number=132] resolved by [Diana]
Done! Trouble [number=165] resolved by [Diana]
Done! Trouble [number=198] resolved by [Diana]
Done! Trouble [number=231] resolved by [Elmo]
Done! Trouble [number=264] resolved by [Fred]
Done! Trouble [number=297] resolved by [Elmo]
Fail  Trouble [number=330]
Done! Trouble [number=363] resolved by [Elmo]
Fail  Trouble [number=396]
Done! Trouble [number=429] resolved by [Charlie]
Fail  Trouble [number=462]
Done! Trouble [number=495] resolved by [Elmo]
</code></pre>
<h2 id="등장인물"><a href="#%EB%93%B1%EC%9E%A5%EC%9D%B8%EB%AC%BC" aria-hidden="true"><span class="icon icon-link"></span></a>등장인물</h2>
<h3 id="handler처리자의-역할"><a href="#handler%EC%B2%98%EB%A6%AC%EC%9E%90%EC%9D%98-%EC%97%AD%ED%95%A0" aria-hidden="true"><span class="icon icon-link"></span></a>Handler(처리자)의 역할</h3>
<p>요구를 처리하는 인터페이스(API)를 결정하는 역할을 합니다.</p>
<p>다음사람을 준비해두고,</p>
<p>자신이 처리할 수 없는 요구가 나오면 떠넘기기를 합니다.</p>
<p>예제 : Support</p>
<h3 id="concretehandler구체적인-처리자의-역할"><a href="#concretehandler%EA%B5%AC%EC%B2%B4%EC%A0%81%EC%9D%B8-%EC%B2%98%EB%A6%AC%EC%9E%90%EC%9D%98-%EC%97%AD%ED%95%A0" aria-hidden="true"><span class="icon icon-link"></span></a>ConcreteHandler(구체적인 처리자)의 역할</h3>
<p>예제 : NoSupport, LimitSupport, OddSupport, SpecialSupport</p>
<h3 id="client요구자의-역할"><a href="#client%EC%9A%94%EA%B5%AC%EC%9E%90%EC%9D%98-%EC%97%AD%ED%95%A0" aria-hidden="true"><span class="icon icon-link"></span></a>Client(요구자)의 역할</h3>
<p>ConcreteHandler에게 요구하는 역할입니다.
예제 : Main</p>
<h2 id="독자의-사고를-넓히기-위한-힌트"><a href="#%EB%8F%85%EC%9E%90%EC%9D%98-%EC%82%AC%EA%B3%A0%EB%A5%BC-%EB%84%93%ED%9E%88%EA%B8%B0-%EC%9C%84%ED%95%9C-%ED%9E%8C%ED%8A%B8" aria-hidden="true"><span class="icon icon-link"></span></a>독자의 사고를 넓히기 위한 힌트</h2>
<h3 id="요구하는-사람과-요구를-처리하는-사람을-유연하게-연결한다"><a href="#%EC%9A%94%EA%B5%AC%ED%95%98%EB%8A%94-%EC%82%AC%EB%9E%8C%EA%B3%BC-%EC%9A%94%EA%B5%AC%EB%A5%BC-%EC%B2%98%EB%A6%AC%ED%95%98%EB%8A%94-%EC%82%AC%EB%9E%8C%EC%9D%84-%EC%9C%A0%EC%97%B0%ED%95%98%EA%B2%8C-%EC%97%B0%EA%B2%B0%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="icon icon-link"></span></a>요구하는 사람과 요구를 처리하는 사람을 유연하게 연결한다</h3>
<p>이 패턴의 핵심은 Client와 ConcreteHandler들을 유연하게 연결하는 것 입니다.</p>
<p>Client는 최초사람에게 요구를 합니다.</p>
<p>그러면 뒷일은 적절한 처리자에게 전달되서 원하는 정보를 return 받습니다.</p>
<p>만약 이패턴을 사용하지 않는다면, 각 항목에 대한 처리를 누가해야하는지 중앙집권적으로 가지고 있어야 합니다.</p>
<p>그 정보를 Client가 갖게하는것은 별로 현명하지 않습니다.</p>
<p>요구를 하는 사람들이 처리자의 역할분담에 대해서까지 자세히 알아야 하는것은 부품으로써의 독립성이 훼손됩니다.</p>
<pre><code>요약 : 인터넷 해지를 위해 전화 한 사람이, 해지해주세요! 하면,

인터넷 업체는 알아서 해지부서에 연락해서 해지 처리하고 정보를 주면 된다.
</code></pre>
<p><em>예제는 단순화를 위해서 Main에 사슬형성을 맡겼지만, 사슬형성은 요구하는 사람이 갖는게 아닙니다.</em></p>
<h3 id="동적으로-사슬의-형태를-바꾼다"><a href="#%EB%8F%99%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%82%AC%EC%8A%AC%EC%9D%98-%ED%98%95%ED%83%9C%EB%A5%BC-%EB%B0%94%EA%BE%BC%EB%8B%A4" aria-hidden="true"><span class="icon icon-link"></span></a>동적으로 사슬의 형태를 바꾼다</h3>
<p>예제에선 Alice 부터 Fred까지, 고정된 순서로 되어 있습니다.</p>
<p>예를들어 패턴 1,2,3 에 따라 처리순서가 바뀌어야 한다고 가정하면,</p>
<p>중앙집권적으로 처리하는 것보다 쉽게, 동적으로 변경이 가능하게 됩니다.</p>
<h3 id="자신의-일에-집중할-수-있다"><a href="#%EC%9E%90%EC%8B%A0%EC%9D%98-%EC%9D%BC%EC%97%90-%EC%A7%91%EC%A4%91%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8B%A4" aria-hidden="true"><span class="icon icon-link"></span></a>자신의 일에 집중할 수 있다</h3>
<p>'떠넘기기'는 부정적인 의미가 강하지만,
반대로 각 오브젝트가 '자신의 일에 집중할 수 있다'는 의미이기도 합니다.</p>
<p>Chain Of Responsibility 패턴을 사용하지 않을땐 '위대한 사람 한 명이 누가 요구를 처리할지 전부 결정' 하는 방법으로 합니다.</p>
<p>또는 '자신이 처리할 수 없으면 다른사람에게 맡기고, 만약 그래도 처리할 수 없으면 시스템 상황에 따라서 적절한 사람' 에게 처리를 맡기는 '일의 분담'까지 각각의 ConcreteHandler 역할에게 부담시켜야 합니다.</p>
<h3 id="떠넘기기로-처리가-지연되지-않을까"><a href="#%EB%96%A0%EB%84%98%EA%B8%B0%EA%B8%B0%EB%A1%9C-%EC%B2%98%EB%A6%AC%EA%B0%80-%EC%A7%80%EC%97%B0%EB%90%98%EC%A7%80-%EC%95%8A%EC%9D%84%EA%B9%8C" aria-hidden="true"><span class="icon icon-link"></span></a>떠넘기기로 처리가 지연되지 않을까</h3>
<p>맞습니다. 이건 트레이드 오프의 문제입니다.</p>
<p>요구와 처리자의 관계가 고정적이고 처리속도가 상당히 중요한 경우에는 사용하지 않는 편이 유효한 case도 있습니다.</p>
</div></article></section><footer>© 2017 <a>flybook</a>. All rights reserved.</footer></div></div>
      </body>
    </html>
  